---
title: 数算B往年题-2022
date: 2025-06-17
details: xianyu & aq
---
# 数算B往年题-2022

## **一. 选择题**

1. **D**。在一个双向链表中，要在结点 `p` 之前插入一个新结点 `q`，需要进行四次指针调整。选项 D `p.prev.next=q; q.next=p; q.prev=p.prev; p.prev=q;` 以一个有效的顺序正确地完成了这些操作 。

   - > [!note]
     >
     > 带入选项验证

2. **D**。对 `N` 个元素进行递归二分查找，每一步都会将问题规模减半。递归的最大深度约等于 `log₂(N)`。精确的最小栈容量需求为 `⌈log₂(N+1)⌉`，在选项中表示为 `[Log₂(N+1)]` 。

   - > [!note]
     >
     > 重要公式$\frac{N}{2^i}=1$,其中i为二分次数,递归栈的深度应该为i+1

3. **B**。数据结构三要素包括逻辑结构、存储结构和运算。

   * **逻辑结构**描述数据元素间的关系，如`线性表`和`二叉树`。
   * **存储结构**（物理结构）描述逻辑结构在内存中的实现方式。**`链表`** 是一种存储结构。
   * > [!note]
     >
     > 逻辑结构:线性结构和非线性结构
     >
     > 存储结构:顺序存储,链式存储,散列存储

4. **B**。在用数组 `Q[0..m-1]` 实现的循环队列中，`rear` 指向队尾元素的实际位置，`length` 为队列中的元素个数。队首元素 `front` 的位置可以通过 `front = (rear - length + 1) % m` 计算得出。为了处理负数取模的情况，通常写作 `(rear - length + 1 + m) % m`。选项 B `(1+rear+m-length) % m` 与此等价。

   - > [!note]
     >
     > 使用短的例子归纳

5. **D**。前序遍历为 `根, 左, 右`，中序遍历为 `左, 根, 右`。如果两个序列相同，意味着对于树中的每一个结点，其左子树都必须为空 。因此，这棵树要么只有一个根结点，要么所有非叶子结点都只有右子树 。

   - > [!note]
     >
     > 直接画出简单的二叉树模拟(需要抽象一点理解,子节点既可能是叶节点也可能是子树)

6. **B**。霍夫曼树的带权外部路径长度（WPL）等于其所有内部（非叶子）结点权重之和。

   * 待编码权值: {3, 4, 5, 6, 8, 9, 11, 12}。
   * 构建过程中产生的内部结点权重为：7, 11, 15, 20, 23, 35, 58。
   * WPL = 7 + 11 + 15 + 20 + 23 + 35 + 58 = **169**。
   * > [!note]
     >
     > aq老师,伟大!

7. **B**。当待排序数据（1GB）远大于可用内存（100MB）时，需要使用外部排序算法。**归并排序**是外部排序的基础，因为它能高效地顺序处理存储在磁盘上的数据，通过分块排序、多路归并的方式完成排序 。

   - > [!note]
     >
     > 比较的新颖,意思是我的所有操作需要在内存里面完成,但是内存不足(初始数据都放不下),所以使用归并排序

8. **C**。根据握手定理，**图中所有顶点的度数之和等于边数的两倍**。

   * 度数总和 = 2 * 18 = 36。
   * 已知顶点的度数和 = (3个 * 度4) + (4个 * 度3) = 12 + 12 = 24。
   * 剩余顶点的度数之和 = 36 - 24 = 12。
   * 这些剩余顶点的度数均小于3（即为1或2）。为了使顶点总数最少，需要让剩余顶点的个数 `k` 最少，即它们的度数应尽可能大（取2）。
   * `2k ≥ 12`，因此 `k` 的最小值为 6。
   * 最少顶点总数 = 已知顶点数 + k = (3 + 4) + 6 = **13**。

9. **C**。给定的边集合构成了一个深度优先遍历（DFS）生成树。在无向图的DFS中，不存在连接两个不同子树的“横叉边”（即边上的两个顶点互不为祖先关系）。

   * `V3` 在以 `V1` 为根的子树中。
   * `V4` 是从 `V0` 出发的另一个分支的根。
   * 因此，边 **(V4, V3)** 将是一条横叉边，这样的边在无向图的DFS中是不可能存在的。
   * > [!note]
     >
     > 画出整个树即可

10. **B**。题目中“逆邻接表”很可能是笔误，因为图示是标准的“邻接表”（出度表）格式。假设其为标准邻接表，从 `v0` 开始进行DFS（优先访问索引小的邻居）：

    1.  访问 `v0`。
    2.  访问 `v0` 的邻居 `v1`。
    3.  访问 `v1` 的未访问邻居 `v2`。
    4.  回溯后，访问 `v0` 的另一邻居 `v3`。
    5.  访问 `v3` 的未访问邻居 `v4`。
    * 最终遍历序列为 **v0, v1, v2, v3, v4**。

11. **D**。不稳定的排序算法是指它不能保证相等元素的原始相对顺序。
    * 冒泡排序、归并排序、直接插入排序都是稳定的。
    * **希尔排序**由于其跳跃式的比较和交换，是典型的不稳定排序算法。

12. **C**。比较各排序算法的最坏情况时间复杂度：

    * 快速排序: `O(N²)`
    * 堆排序: `O(N log N)`
    * 归并排序: `O(N log N)`
    * 选择排序: `O(N²)`
    * **快速排序**和**选择排序**的最坏情况时间复杂度相同，均为 `O(N²)` 。
    * > [!note]
      >
      > | **算法 (Algorithm)**          | **平均时间复杂度 (Average Time)** | **最好时间复杂度 (Best Time)** | **最坏时间复杂度 (Worst Time)** | **空间复杂度 (Space)** | **稳定性 (Stability)** |
      > | ----------------------------- | --------------------------------- | ------------------------------ | ------------------------------- | ---------------------- | ---------------------- |
      > | **冒泡排序 (Bubble Sort)**    | O(n2)                             | O(n)                           | O(n2)                           | O(1)                   | 稳定 (Stable)          |
      > | **选择排序 (Selection Sort)** | O(n2)                             | O(n2)                          | O(n2)                           | O(1)                   | 不稳定 (Unstable)      |
      > | **插入排序 (Insertion Sort)** | O(n2)                             | O(n)                           | O(n2)                           | O(1)                   | 稳定 (Stable)          |
      > | **希尔排序 (Shell Sort)**     | O(nlogn) to O(n2)                 | O(nlogn)                       | O(n2)                           | O(1)                   | 不稳定 (Unstable)      |
      > | **归并排序 (Merge Sort)**     | O(nlogn)                          | O(nlogn)                       | O(nlogn)                        | O(n)                   | 稳定 (Stable)          |
      > | **快速排序 (Quick Sort)**     | O(nlogn)                          | O(nlogn)                       | O(n2)                           | O(logn)                | 不稳定 (Unstable)      |
      > | **堆排序 (Heap Sort)**        | O(nlogn)                          | O(nlogn)                       | O(nlogn)                        | O(1)                   | 不稳定 (Unstable)      |

13. **C**。
    * 先根遍历 (`根, 左, 右`) 中 X 在 Y 之前，说明 Y 不可能是 X 的祖先。
    * 后根遍历 (`左, 右, 根`) 中 X 在 Y 之后，说明 Y 不可能是 X 的后裔。
    * 唯一满足这两个条件的关系是 **X 是 Y 的祖先** 。
    * > [!note]
      >
      > 考虑画一个最简单的三节点二叉树来模拟各个选项

14. **C**。对于一个森林，`V - E = T`（V=顶点总数, E=边总数, T=树的数量）。

    * 设 `L` 为叶子结点数，`N` 为度为2的结点数，`N1` 为度为1的结点数 。
    * `V = L + N1 + N`。
    * 边的总数 `E` 等于所有非叶子结点的出度之和：`E = (N1 * 1) + (N * 2)`。
    * 代入公式：`T = V - E = (L + N1 + N) - (N1 + 2N) = L - N`。
    * 森林中树的个数为 **L - N**。
    * > [!note]
      >
      > 感谢aq老师的耐心讲解!
      >
      > $n_2=n_0-1$,即在单棵树中度数为2的节点比度数为0的节点少1

15. **C**。回溯法是一种深度优先的搜索策略，其实现依赖于递归，而递归的执行过程隐式地使用了**栈**来保存搜索路径。**队列**是广度优先搜索使用的数据结构。因此，关于回溯法需要借助队列的说法是错误的。

***
## **二. 判断题**

1. **(对)**。一个连通无环的无向图是树的定义 。树有 `N` 个顶点和 `N-1` 条边，移除任意一条边都会破坏其连通性 。
2. **(对)**。根据给定的前序序列 (`HGEDBFCA`) 和中序序列 (`EGBDHFAC`) 可以唯一确定一棵二叉树。对此树进行后序遍历，得到的序列确实是 `EBDGACFH`。

   - > [!note]
     >
     > 可以唯一确定的遍历组合
     >
     > - 前序+中序
     >
     > - 后序+中序
     >
     > 在还原树的时候结合两个顺序可以确定根节点,然后缩小问题的规模,最终还原整棵树
3. **(错)**。二叉搜索树的查找路径必须遵循“小走左，大走右”的原则。

   * 路径 B: `925, 202, 911, 240, 912, ...` 是无效的。从 240 (在 911 的左子树) 不可能走到 912，因为 912 > 911。
   * 路径 C: `935, 278, 347, 621, 299, ...` 也是无效的。从 347 右拐到 621 后，其子树中所有节点值都必须大于 347，而 299 < 347。
   * 由于存在无效路径，该论述为假。
   * > [!note]
     >
     > 建议先构建出整个二叉搜索树,然后逐个检查节点的左子树和右子树是否满足要求
4. **(错)**。使用自底向上的 `heapify` 算法，从一个包含N个结点的数组构建堆的时间复杂度为 **O(N)**，而不是 O(Nlog₂N)。

   - > [!note]
     >
     > 这个真不知道
5. **(对)**。这是队列（FIFO, 先进先出）的定义。出队操作移除的总是集合中存在时间最长的元素。
6. **(对)**。拓扑排序可以通过两种经典算法实现：一种是基于广度优先搜索（Kahn算法），另一种是基于深度优先搜索。
7. **(错)**。这个结论只在所有边的权值都唯一时成立 。如果存在多条权值相同的最小边，一个最小生成树可能包含其中一条，而另一个最小生成树可能包含另一条。
8. **(错)**。迪杰斯特拉（Dijkstra）算法的贪心策略要求所有边的权值都是非负的。如果图中存在负权边，该算法可能无法给出正确的答案。
9. **(对)**。这是对分治算法思想的准确描述。
10. **(对)**。最优子结构是应用动态规划算法解决问题的必要条件。它意味着一个问题的最优解包含了其子问题的最优解。

***
## **三. 填空题**

1. **O(m*(n-m+1))** 或简化为 **O(mn)**。朴素模式匹配算法在最坏情况下，对于目标串中 `n-m+1` 个可能的起始位置，都需要与模式串进行 `m` 次字符比较。

2. **((k-1)n + 1) / k**。在一棵有 `n` 个结点的树中，如果只存在度为 `k` 的分支结点和度为 0 的叶子结点，通过 `n = L + N_k` 和 `n = k * N_k + 1` 两个关系式（L为叶子数，N_k为分支结点数）可以解出叶子结点数 `L` 。

3. **[40, 38, 46, 56, 70, 80]** （这是一个标准划分算法可能产生的结果，其他结果也可能有效）。以第一个记录 `46` 为基准进行第一次划分后，所有小于 `46` 的元素（`38`, `40`）被移动到其左侧，大于 `46` 的元素被移动到其右侧。

   - > [!note]
     >
     > 1. 找到基准值,一般取第一个值为基准值
     > 2. 设置两个指针left和right
     > 3. 当左指针指到比基准大的值停下来,当右指针指到比基准值小的值停下来,都停下来则做一次交换,交换完毕后两指针同时向内移动
     > 4. 当left>=right,取基准值与right交换

4. **11/8** (或 1.375)。平均查找长度 (ASL) = Σ(查找第i个元素的概率 * 找到第i个元素的比较次数)。

   * ASL = `(1/2 * 1) + (1/4 * 2) + (1/8 * 3) = 4/8 + 4/8 + 3/8 = 11/8`。

5. **4**。我们需要在关键字集合中找出满足 `key MOD 13 = 1` 的所有记录。

   * `14 MOD 13 = 1`
   * `1 MOD 13 = 1`
   * `27 MOD 13 = 1`
   * `79 MOD 13 = 1`
   * 共有 **4** 个记录的散列地址为1。

6. **n - i**。在长度为 `n` 的顺序表中删除第 `i` 个元素，需要将第 `i+1` 到第 `n` 个元素（共 `n-i` 个）向前移动一位。(**可以举例子归纳**)

7. **3**。初始小根堆为 `[8, 15, 10, 21, 34, 16, 12]` 。删除 `8` 后，将末尾元素 `12` 移至堆顶，然后向下调整（sift-down）。

   > [!note]
   >
   > 作为根节点要与两个孩子作比较,和较小的那一边交换,要比2次

   1.  `12` 与其较小的孩子 `10` 比较（第1次比较是`15`和`10`比，第2次是`12`和`10`比）。交换。
   2.  `12` 到达新位置，与其孩子 `16` 比较（第3次比较）。`12 < 16`，调整结束。

   * 共需 **3** 次关键字比较。

8. **拓扑排序**。拓扑排序算法仅适用于有向无环图（DAG）。如果一个有向图存在环路，则拓扑排序算法会失败（例如，无法将所有顶点都输出），从而可以判断出环的存在。

> [!note]
>
> 可以使用Kahn算法,对应的是BFS
>
> 或者是一般的DFS,按照结束遍历时间从大到小排序,对应的是DFS

1. **n**。一个包含 `n` 个顶点的有向强连通图最少需要 **n** 条边，构成一个简单的有向环即可。

2. **45**。该过程模拟了后缀表达式的求值。

   * **初始**: S1(操作数栈): `[5, 8, 3, 2]` (2在顶)； S2(运算符栈): `[*, -, /]` (/在顶)。
   1.  **第一次F()**: 弹出 2, 3 和 /。计算 `3 / 2 = 1`。压入1。S1: `[5, 8, 1]`。
   2.  **第二次F()**: 弹出 1, 8 和 -。计算 `8 - 1 = 7`。压入7。S1: `[5, 7]`。
   3.  **第三次F()**: 弹出 7, 5 和 *。计算 `5 * 7 = 35`。压入35。S1: `[35]`。
   * 三次调用后，S1栈顶的值是 **35**。

***
## **四. 简答题**

### 1. Dijkstra 算法

使用Dijkstra算法求顶点1到其余各顶点的最短路径，过程如下表所示。`D[i]`表示从顶点1到顶点`i`的当前最短路径长度。

> [!note]
>
> 1. 当节点被加入到U中,则到达该节点的最短路径将不会更新,为了避免干扰,可以将下面全部置空,到最后再填上去
> 2. 检查节点的更新是否正确,即一个节点只能在有入度的时候被更新,如果没有出度则无法更新其他节点
>
> > [!tip]
> >
> > 1. 初始化,设置源点到自己的距离为0,到其他点的距离设为$\infin$
> > 2. 每次从S中选取已知到当前源点距离最小的点P(需要维护优先队列)
> > 3. 将该点放入U中,更新由源点经由P到达与P相连的节点的最短路径(与已记录的值作比较)
> > 4. 回到2,直到S为空

| 所选顶点 | U (已确定最短路径的顶点集合) | D[2] | D[3] | D[4] | D[5] | D[6] | D[7] | D[8] |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **初态** | {1} | 30 | ∞ | 60 | **10** | ∞ | ∞ | ∞ |
| **5** | {1, 5} | **25** | ∞ | 60 | 10 | **17** | ∞ | ∞ |
| **6** | {1, 5, 6} | **20** | **33** | 60 | 10 | 17 | **25** | ∞ |
| **2** | {1, 5, 6, 2} | 20 | 33 | 60 | 10 | 17 | **25** | ∞ |
| **7** | {1, 5, 6, 2, 7} | 20 | **31** | **28** | 10 | 17 | 25 | **35** |
| **4** | {1, 5, 6, 2, 7, 4} | 20 | 31 | 28 | 10 | 17 | 25 | 35 |
| **3** | {1, 5, 6, 2, 7, 4, 3} | 20 | 31 | 28 | 10 | 17 | 25 | 35 |
| **8** | {1, 5, 6, 2, 7, 4, 3, 8} | 20 | 31 | 28 | 10 | 17 | 25 | 35 |

---
### 2. 二叉排序树

给定关键码集合: {18, 73, 5, 10, 68, 99, 27} 。

**a) 按顺序构建的二叉排序(搜索)树** 

```
      18
     /  \
    5    73
     \   /  \
     10 68   99
        /
       27
```

**b) 删除关键码为73后的二叉排序树**
删除拥有两个子结点的结点时，可以用其中序前驱（左子树中的最大值）或中序后继（右子树中的最小值）来替代。此处使用中序前驱 `68` 进行替换。

```
      18
     /  \
    5    68
     \   /  \
     10 27   99
或者使用99来替换,只要最终符合二叉搜索树的性质即可     
      18
     /  \
    5    99
     \   /  
     10 68 
     	/
       27
```

**c) 查询效率最高的最优二叉排序树**
在查询概率相等的情况下，最平衡的二叉搜索树即为最优。通过递归地选择有序序列的中位数作为根来构建,所以需要先排序。

* 有序序列: {5, 10, 18, 27, 68, 73, 99}。
* 根为中位数 **27**。

```
          27
         /  \
       10    73
      / \   /  \
     5  18 68  99
```

---
### 3. 奇偶交换排序

给定序列: {18, 73, 5, 10, 68, 99, 27, 10}。

**a) 前4趟排序的结果**

* **初始:** `{18, 73, 5, 10, 68, 99, 27, 10}`
* **第1趟 (奇数):** 比较(a₁,a₂), (a₃,a₄), (a₅,a₆), (a₇,a₈)。
    `{18, 73, 5, 10, 68, 99, 10, 27}`
* **第2趟 (偶数):** 比较(a₂,a₃), (a₄,a₅), (a₆,a₇)。
    `{18, 5, 73, 10, 68, 10, 99, 27}`
* **第3趟 (奇数):**
    `{5, 18, 10, 73, 10, 68, 27, 99}`
* **第4趟 (偶数):**
    `{5, 10, 18, 10, 73, 27, 68, 99}`

**b) 是否是稳定的排序**
**是稳定的**。奇偶交换排序只在相邻元素间进行比较和交换，且交换条件是严格大于 `a[i] > a[i+1]` 。这保证了相等元素的相对顺序不会改变。

**c) 在“正序”和“逆序”情况下的比较和交换次数** 

* **初始状态: “正序”**
  
    * **比较次数:** 算法需要完整的一趟（一个奇数趟和一个偶数趟）来确认序列已有序。共需 `n-1` 次比较。
    * > [!note]
      >
      > 把奇数次和偶数次结合起来考虑,可以考虑使用几个短的序列模拟,归纳关系
    * **交换次数:** **0**。
* **初始状态: “逆序”**
    * **比较次数:** 在最差情况下，算法需要执行 `n` 趟（即 `n/2` 轮“奇数+偶数”循环）才能完成排序。每一轮“奇数+偶数”循环包含 `n-1` 次比较。则总比较次数为$ \lceil n/2 \rceil \times (n-1) $ 
    * **交换次数:**  在逆序情况下，元素的每一次交换都会消除一个“逆序对”。逆序序列的总逆序对数量为 $ n(n-1)/2 。为了将序列变为有序，必须消除所有的逆序对。总交换次数为：  \lceil n/2 \rceil \times (n-1) $ 次。

***
## **五. 算法填空**

### 1. 单链表颠倒

```python
class Node:
    def __init__(self, data, next=None):
        self.data, self.next = data, next

class LinkList:
    def __init__(self, lst):
        self.head = Node(lst[0])
        p = self.head
        for i in lst[1:]: # 一点一点往前推进
            node = Node(i)
            p.next = node     # (1)
            p = p.next        # (2)

    def reverse(self):
        p = self.head.next # p先指向第二个节点,防止丢失引用
        self.head.next = None # (3) # 主要思路是将所有的链表关系反转
        # 初始化的时候将头节点的下一个节点置空
        while p is not None:
            q = p
            p = p.next        # (4)
            q.next = self.head  # (5)
            self.head = q     # (6)

    def print(self):
        p = self.head
        while p:
            print(p.data, end=" ")
            p = p.next
        print()

# 主程序部分
# 注意：题目示例有两行输入，但代码只处理了一行，这里以代码逻辑为准
a = list(map(int, input().split()))
a = LinkList(a)
a.reverse()
a.print()
```

### 2. 构建二叉树并中序遍历

该算法从扩充二叉树的先根序列构建树，然后输出其中根遍历序列。

```python
# ... (class BinaryTree)
def inorderTraversal(self): #中序遍历
    if self.left:
        self.left.inorderTraversal()    # (1)
    print(self.data, end="")
    if self.right:
        self.right.inorderTraversal()   # (2)

def buildTree():
    global ptr
    if s[ptr] == "@":
        ptr += 1
        return None                     # (3)
    tree = BinaryTree(s[ptr])           # (4)
    ptr += 1
    tree.addLeft(buildTree())           # (5)
    tree.addRight(buildTree())          # (6)
    return tree

tree = buildTree()                      # (7)
tree.inorderTraversal()
```