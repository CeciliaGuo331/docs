---
title: 数算B往年题-2021
date: 2025-06-17
details: xianyu & aq
---
# 数算B往年题-2021

## 选择题

1. **正确答案：C**
    * **解析**：算法的时间复杂性，即算法运行所需的时间，主要由以下三个因素决定：
        * **A: 问题的规模 (n)**：输入数据的大小，是影响复杂性的最主要因素。
        * **B: 输入值**：对于某些算法，特定的输入数据会影响其性能。例如，快速排序在处理已排序的数组时性能会下降到 $O(n^2)$。
        * **D: 算法的策略**：算法本身的设计，是决定其效率的根本。
    * **C: 计算结果** 本身不会影响计算该结果所花费的时间。

---

2. **正确答案：A**
    * **解析**：链表的特点分析：
        * **A: 可随机访问任意元素**：这是**错误**的。链表的节点存储在非连续的内存空间中，要访问某个元素，必须从头节点开始，沿着指针逐个向后查找，这属于**顺序访问**，而非随机访问。数组才具有随机访问的特性。
        * **B: 插入和删除不需要移动元素**：这是链表的主要优点。插入或删除时，只需要修改目标位置前后节点的指针即可，时间复杂度为 O(1)（如果已知前后节点）。
        * **C: 不必事先估计存储空间**：链表是动态数据结构，可以在运行时按需分配内存。
        * **D: 所需空间与线性表长度成正比**：每增加一个元素，就分配一个节点的空间。

---

3. **正确答案：C**
    * **解析**：这是一个经典的卡特兰数问题，考察栈的后进先出（LIFO）特性。出栈顺序的规律是：在出栈序列中，任何一个元素后面的、比它先进栈的元素，必须按进栈顺序的逆序出栈。
        * 对于 **C: ZXY**，要让 Z 先出栈，必须 X, Y, Z 都已进栈。此时栈中的状态是 (从栈底到栈顶) X, Y。在 Z 出栈后，Y 在 X 的上面，所以 Y 必须比 X 先出栈。因此，不可能得到 Z 后面紧跟着 X 的出栈顺序。
        * A (XYZ): 进X, 出X; 进Y, 出Y; 进Z, 出Z。可行。
        * B (YZX): 进X, 进Y, 出Y; 进Z, 出Z; 出X。可行。
        * D (ZYX): 进X, 进Y, 进Z, 出Z, 出Y, 出X。可行。
        
    * > [!note]
        >
        > 直接模拟各个选项即可

---

4. **正确答案：A**
    * **解析**：在链表实现的队列（或任何链式结构）中，通常有一个头指针 `head` 指向链表的第一个节点。如果这个 `head` 指针为 `None` (或 `NULL`)，说明链表中没有任何节点，因此队列为空。
        * B: `Q == None` 判断的是队列对象本身是否存在，而不是队列是否为空。
        * C: `Q.head == 0` 通常用于数组实现，且 0 是一个无效索引或特殊标记。
        * D: `Q.head != None` 表示队列**不为空**。

---

5. **正确答案：B**
    * **解析**：
        * 前序遍历序列：根, [左子树], [右子树]
        * 后序遍历序列：[左子树], [右子树], 根
        * 如果前序序列是后序序列的**逆序**，那么 `(根, [左], [右])` 等于 `reverse([左], [右], 根)`，即 `(根, reverse([右]), reverse([左]))`。
        * 这意味着，在树的任何一个节点，它的左子树的前序遍历序列必须是其右子树后序遍历序列的逆序，并且右子树的前序遍历序列是其左子树后序遍历序列的逆序。这个递归性质强制要求在每个节点上，其左、右子树中**必须有一个为空**。
        * 这样的二叉树是一棵**退化二叉树**（或称倾斜二叉树），形态类似于一个链表。对于这样的树，如果根节点在第0层，其高度等于其节点数。
        * > [!note]
          >
          > 注意题目表述有无包含关系

---

6. **正确答案：B**
    * **解析**：叶子节点没有子树。对于任意两个叶子节点 L1 和 L2，它们在树中的相对左右位置是固定的。无论是前序、中序还是后序遍历，遍历算法都是先处理完一个子树再去处理另一个子树。因此，如果 L1 在 L2 的左边（即 L1 在某个共同祖先节点的左子树中，而 L2 在右子树中），那么在三种遍历中，L1 始终会先于 L2 被访问。所以，所有叶子节点在三种遍历序列中的相对次序是**不发生改变**的。

---

7. **正确答案：D**
    * **解析**：这是一个多关键字排序问题。规则是 key1 为主关键字，key2 为次关键字。实现这种排序的经典方法是：先按**次要关键字**（key2）进行排序，然后再用一种**稳定**的排序算法按**主要关键字**（key1）进行排序。
      
        * **稳定排序算法**：能保证在排序后，值相同的元素的原始相对顺序保持不变。常见的稳定排序有：冒泡排序、插入排序、归并排序。
        * **不稳定排序算法**：选择排序、快速排序、希尔排序、堆排序。
        * 分析选项：
            * A/C: 都是先排主关键字 key1，方法错误。
            * B: 后按 key1 排序时用了**直接选择排序**，它是不稳定的，会打乱之前按 key2 排好的顺序。错误。
            * D: 先按 key2 排序（用任何算法都可以），然后用**冒泡排序**（稳定）按 key1 排序。这能保证当 key1 相同时，它们按 key2 排好的顺序得以保留。**正确**。
        
    * > [!note]
        >
        > 注意稳定性
        >
        > 稳定的排序算法只有三个:冒泡排序,插入排序,选择排序
        >
        > **1. 冒泡排序 (Bubble Sort)**
        >
        > - **工作流程:**
        >   1. 从序列的开头开始，比较相邻的元素。如果它们的顺序不对（例如，在升序排序中，第一个元素比第二个元素大），则交换它们的位置。
        >   2. 每一轮比较结束后，最大的（或最小的）元素会“冒”到序列的末尾（或开头）。
        >   3. 重复上述过程，但每一轮比较的范围可以缩小，因为末尾的元素已经就位。
        >   4. 如果某一轮比较下来没有发生任何交换，则说明序列已经排序完成，可以提前结束。
        > - **特点:**
        >   - **优点:** 简单直观，容易实现。
        >   - **缺点:** 效率低下，尤其是在大规模数据集上，时间复杂度在最坏情况、平均情况和最好情况下都为 O(n^2)。通常只适用于小型数据集。
        >
        > **2. 选择排序 (Selection Sort)**
        >
        > - **工作流程:**
        >   1. 在未排序的序列中找到最小（或最大）的元素。
        >   2. 将最小（或最大）的元素与未排序序列的第一个元素交换位置。
        >   3. 在剩余的未排序序列中重复步骤 1 和 2，找到最小（或最大）的元素并与当前未排序序列的第一个元素交换位置。
        >   4. 重复此过程，直到整个序列排序完成。
        > - **特点:**
        >   - **优点:** 实现相对简单，交换次数少（最多进行 n-1 次交换）。
        >   - **缺点:** 效率低下，时间复杂度在最坏情况、平均情况和最好情况下都为 O(n^2)。无论数据是否有序，都需要进行多次比较。
        >
        > **3. 插入排序 (Insertion Sort)**
        >
        > - **工作流程:**
        >   1. 将序列分为已排序部分（初始时只有一个元素）和未排序部分。
        >   2. 从未排序部分的第一个元素开始，取出一个元素看作是需要插入的元素。
        >   3. 将该元素与已排序部分中的元素从后向前进行比较。
        >   4. 如果该元素比已排序部分的某个元素小，则将已排序部分中的该元素向后移动一位。
        >   5. 重复步骤 4，直到找到该元素可以插入的位置（或者到达已排序部分的开头）。
        >   6. 将该元素插入到找到的位置上。
        >   7. 重复步骤 2-6，直到所有未排序部分的元素都插入到已排序部分。
        > - **特点:**
        >   - **优点:** 实现简单，对于少量数据或基本有序的数据效率较高（最好情况下时间复杂度为 O(n)）。稳定的排序算法。
        >   - **缺点:** 对于大规模逆序数据效率较低，最坏情况和平均情况下时间复杂度为 O(n^2)。
        >
        > **4. 归并排序 (Merge Sort)**
        >
        > - **工作流程:**
        >   1. **分治:** 递归地将序列分成两半，直到每个子序列只包含一个元素（认为单个元素的序列是有序的）。
        >   2. **合并:** 将相邻的两个有序子序列合并成一个有序子序列。
        >   3. 合并时，比较两个子序列的第一个元素，将较小的元素放入合并后的序列中，并取该子序列的下一个元素。
        >   4. 重复此过程，直到其中一个子序列变空，然后将另一个子序列的剩余元素添加到合并后的序列的末尾。
        >   5. 重复步骤 2-4，直到整个序列被合并成一个有序序列。
        > - **特点:**
        >   - **优点:** 效率高，时间复杂度在最坏情况、平均情况和最好情况下都为 O(n log n)。稳定的排序算法。
        >   - **缺点:** 需要额外的存储空间来存储合并后的序列，空间复杂度为 O(n)。
        >
        > **5. 快速排序 (Quick Sort)**
        >
        > - **工作流程:**
        >   1. **选择基准:** 从序列中选择一个元素作为“基准”（pivot）。通常选择第一个、最后一个、中间元素或随机选择一个元素。
        >   2. **分区:** 将序列重新排列，使所有比基准小的元素都放在基准的左边，所有比基准大的元素都放在基准的右边。基准本身则处于最终的排序位置。
        >   3. **递归:** 递归地对基准左边的子序列和右边的子序列重复步骤 1 和 2。
        >   4. **终止:** 当子序列只包含一个元素或为空时，递归停止。
        > - **特点:**
        >   - **优点:** 效率高，平均情况下时间复杂度为 O(n log n)。原地排序算法（不需要额外的存储空间，除了递归栈）。
        >   - **缺点:** 在最坏情况下（例如，每次选择的基准都是最大或最小元素），时间复杂度为 O(n^2)。不稳定的排序算法。
        >
        > **6. 堆排序 (Heap Sort)**
        >
        > - **工作流程:**
        >   1. **构建堆:** 将序列构造成一个二叉堆（通常是最大堆）。在最大堆中，父节点的值大于或等于其子节点的值。
        >   2. **排序:** 将堆的根节点（最大元素）与堆的最后一个元素交换位置。
        >   3. **调整堆:** 将堆的大小减 1，并从根节点开始重新调整堆，使其满足堆的性质。
        >   4. **重复:** 重复步骤 2-3，直到堆的大小为 1。
        > - **特点:**
        >   - **优点:** 效率高，时间复杂度在最坏情况、平均情况和最好情况下都为 O(n log n)。原地排序算法。
        >   - **缺点:** 实现相对复杂。不稳定的排序算法。

---

8. **正确答案：D**
    * **解析**：要从 n 个整数中找到最小值，你需要将每个数都与当前的“候选最小值”进行比较。一个简单的算法是：
        1. 假设第一个数是最小值。
        2. 将这个“候选最小值”与剩下的 **n-1** 个数逐一比较，如果遇到更小的数，就更新“候选最小值”。
        3. 这个过程至少需要进行 **n-1** 次比较才能确保找到真正的最小值。

---

9. **正确答案：C**
    * **解析**：在有 n 个顶点的无向完全图中，每个顶点都与其他所有 (n-1) 个顶点相连。如果我们直接用 `n * (n-1)` 来计算，每条边（例如，顶点 u 和顶点 v 之间的边）都会被计算两次（一次从 u 到 v，一次从 v 到 u）。因此，总边数需要除以 2。公式为：$$E = \frac{n(n-1)}{2}$$
    
    * > [!note]
      >
      > 一个完全无向图，通常用 **Kn** 表示（其中 *n* 是图中的顶点数），是一个**无向图**，其中**任意一对不同的顶点之间都直接存在着一条边**。

---

10. **正确答案：B**
    
    * **解析**：图 G 的生成树 G' 具有以下性质：
        * A: G' 是 G 的一个**子图**，因为它的顶点集和边集都是 G 的子集。正确。
        * C: G' 是 G 的一个**极小连通子图**，它包含了 G 的所有顶点（V'=V），并且边数最少（n-1 条），刚好能保持图的连通性。正确。
        * D: G' 是一个**无环子图**。树的定义就是无环的连通图。正确。
        * B: G' 是 G 的一个**连通分量**。这个说法是错误的。一个连通分量是图的一个极大连通子图，它可能只包含 G 的一部分顶点（如果 G 本身不连通）。而生成树必须包含 G 的**所有**顶点。如果一个图是连通的，它本身就是一个连通分量，而它的生成树是它的一个子图，而不是“一个连通分量”。
        
    * > [!note]
        >
        > **1. 子图 (Subgraph)**
        >
        > - **定义:** 设 G = (V, E) 是一个图。G' = (V', E') 是 G 的一个**子图**当且仅当：
        >   - V' 是 V 的一个子集 (V' ⊆ V)。
        >   - E' 是 E 的一个子集 (E' ⊆ E)。
        >   - E' 中的所有边 {u, v} 都必须满足 u ∈ V' 且 v ∈ V'。
        >   - 可以更直观地理解为，子图就是从原图中选择出来的一部分顶点和它们之间的部分边，并且被选择出来的边只连接被选择出来的顶点。
        >
        > **2. 极小连通子图 (Minimal Connected Subgraph)**
        >
        > - **定义:** 一个图 G' = (V', E') 是 G 的一个**极小连通子图**当且仅当：
        >   - G' 是 G 的一个子图 (V' ⊆ V, E' ⊆ E)。
        >   - G' 是**连通的**。
        >   - 从 G' 中移除**任何一条边**，G' 将**不再连通**。
        >
        > **3. 连通分量 (Connected Component)**
        >
        > - **定义:** 设 G = (V, E) 是一个无向图。G 的一个**连通分量**是 G 的一个**极大连通子图**。
        >   - **极大连通子图:** 指一个连通子图 G' = (V', E')，使得如果向 G' 中添加任何一个不在 V' 中的顶点，新得到的图将不再连通。
        > - **关键点:**
        >   - 连通分量是图的“连通的组成部分”。
        >   - 一个图可以有多个连通分量。
        >   - 每个连通分量本身都是连通的。
        >   - 不同的连通分量之间互不连通。
        >   - 如果一个图是连通的，那么它就只有一个连通分量。
        >   - 如果一个图是非连通的，那么它就有多个连通分量。
        >
        > **总结区别:**
        >
        > - **子图:** 从原图中选择一部分顶点和边，不一定保持连通。
        > - **极小连通子图:** 连通的子图，且移除任何一条边都会破坏连通。对于给定的顶点子集，是唯一的。
        > - **连通分量:** 图的极大连通子图，是图的连通的组成部分。一个图可以有多个连通分量。

---

11. **正确答案：C**
    * **解析**：题目要求检索关键字 38。散列函数为 `h(key) = key mod 13`。
        * 该哈希表 `[26, 38, ..., 25]`  的构建过程最可能是**线性探测法**来解决冲突，题目中提到的 `H2(Key)` 可能是用来迷惑的。我们用线性探测法来验证表的构造：
            * h(26) = 0 -> 存入地址0
            * h(17) = 4 -> 存入地址4
            * h(33) = 7 -> 存入地址7
            * h(48) = 9 -> 存入地址9
            * h(25) = 12 -> 存入地址12
            * h(38) = 12 -> 冲突！(地址12已有25)
                * 向后探测，地址 `(12+1)%13 = 0` -> 冲突！(已有26)
                * 向后探测，地址 `(12+2)%13 = 1` -> 空闲，存入地址1。
        * 这个过程与图示的哈希表  一致。现在我们来**检索** 38：
        1. **第1次比较**：计算 `h(38) = 38 mod 13 = 12`。检查地址12，存的是25。`38 != 25`。
        2. **第2次比较**：发生冲突，线性向后探测。检查地址 `(12+1)%13 = 0`。存的是26。`38 != 26`。
        3. **第3次比较**：继续向后探测。检查地址 `(12+2)%13 = 1`。存的是38。`38 == 38`。找到。
    * 总共进行了 **3** 次比较。

---

12. **正确答案：C**
    * **解析**：对于任何非空树，有一个重要的性质：**节点总数 (n) = 所有节点的度数之和 + 1** (这是错误的)。正确的性质是：**边数 = 节点总数 - 1**，以及**所有节点的度数之和 = 2 * 边数**。
        * 另一个更直接的公式是：`n_0 = 1 + n_2 + 2*n_3 + 3*n_4 + ...`，其中 `n_i` 是度为 `i` 的节点个数。
        * 本题中，度为3的节点 `n_3 = 2`，度为2的节点 `n_2 = 1`。该树的最大度为3。
        * 代入公式：`n_0 = 1 + (2-1)*n_2 + (3-1)*n_3`
        * `n_0 = 1 + 1*n_2 + 2*n_3`
        * `n_0 = 1 + 1*(1) + 2*(2) = 1 + 1 + 4 = 6`。
    * 所以，度为0的节点（叶子节点）个数为 **6**。

---

13. **正确答案：B**
    * **解析**：
        * **形态不一定相同**：二叉排序树（BST）的最终形态与关键字的**插入顺序**密切相关。例如，用 {10, 20, 30} 按序插入会得到一个向右倾斜的退化树；而用 {20, 10, 30} 插入会得到一个较平衡的树。
        * **平均查找长度也不一定相同**：树的形态（特别是高度）直接决定了查找效率。一个平衡的BST（高度约为 $log_2 n$）的平均查找长度（ASL）远小于一个退化的BST（高度为 n）。
    * 因此，由同一组关键字构造的BST，其形态和ASL都**不一定相同**。

---

14. **正确答案：A**
    * **解析**：**栈 (Stack)** 的后进先出 (LIFO) 特性完美契合了括号配对的需求。算法思路是：
        1. 遍历表达式，遇到开括号（如 `(`, `[`, `{`）就将其压入栈中。
        2. 遇到闭括号（如 `)`, `]`, `}`）就从栈顶弹出一个元素。
        3. 检查弹出的开括号是否与当前闭括号匹配。如果不匹配，或弹出时栈为空，则表达式括号错误。
        4. 遍历结束后，如果栈为空，则括号完全匹配。

---

15. **正确答案：C**
    * **解析**：题目要求为**动态查找表**（dynamic lookup table）选择一个**高效率查找**的结构。动态意味着需要频繁地进行插入和删除操作。
        * A: 有序表（如数组）查找效率高（二分查找 O(log n)），但插入和删除效率低（O(n)），不适合动态场景。
        * B: 堆排序是一种排序算法，不是查找结构。堆本身虽然支持高效的插入和删除最大/最小值（O(log n)），但查找任意元素的效率是 O(n)。
        * C: **二叉排序树 (BST)** 在平均情况下，其查找、插入、删除操作的效率都是 O(log n)，非常适合动态查找。为了保证最坏情况下的性能，通常使用平衡二叉排序树（如AVL树、红黑树）。
        * D: 快速排序是一种排序算法。

***

## 判断题

1. **Y (正确)**: 在长度为n的顺序表（数组）中插入元素，平均需要移动 `n/2` 个元素，所以平均时间复杂度为 $O(n)$。
2. **N (错误)**: 希尔排序通过设置不同的步长（gap），让元素可以一次性地向最终位置大幅跳跃，从而快速减少逆序对。它的核心思想是先让数组基本有序，再使用插入排序进行微调。其效率远高于单纯的直接插入排序，平均时间复杂度优于 $O(n^2)$。
3. **Y (正确)**: 对于这三种排序算法，数据基本有序时，比较和交换的次数都会显著减少。插入排序和冒泡排序在数据完全正序时的最优时间复杂度为 $O(n)$，而逆序时为 $O(n^2)$。希尔排序也受益于数据的有序性。
4. **N (错误)**: 基于散列表的检索，其比较次数除了取决于散列函数和处理碰撞的方法外，还受**装填因子 (load factor)**（即表的填满程度）和**关键字的分布情况**等因素的显著影响。装填因子越高，碰撞概率越大，比较次数越多。
5. **Y (正确)**: 在前序遍历中,要成为最后一个被访问的节点，这个节点必须在整个子树结构的**最右边**。在中序遍历中,根据定义，最后一个被访问的节点**永远是**这棵子树最右边的那个节点。两个遍历的终点都指向了同一个位置——**子树的最右节点**。因此，这个说法是正确的。
6. **Y (正确)**: 前序遍历为（根, 左, 右），后序遍历为（左, 右, 根）。如果一个**非空**二叉树的这两种序列完全相同，那么根节点必须同时在序列的开头和结尾，这只有在序列只有一个元素时才可能。因此，该树只有一个根节点，没有子节点。
7. **Y (正确)**: 对于n个节点，可以构造出多种形态的二叉排序树。其中，最平衡的树（接近完全二叉树）其树高最小（约为 $log_2 n$），查找效率最高。而最不平衡的树（退化树）树高最大（为 n），查找效率最低。因此，树高最小的BST搜索效率最好。
8. **N (错误)**: 强连通分量 (Strongly Connected Component, SCC) 是有向图中的**极大**强连通子图。极大意味着不能再加入图中的任何其他顶点来扩展这个分量，否则就不再强连通。它不是最小的。
9. **Y (正确)**: 邻接矩阵是一个 $n \times n$ 的方阵（n为顶点数）。它所占用的存储空间大小为 $O(n^2)$，只与顶点数 n 有关，与图中实际的边数无关。这使得它在存储稀疏图时空间效率较低。
10. **N (错误)**: 并非所有有向图都存在一个可以到达图中所有其他结点的“根”节点。例如，一个由两个不连通的子图组成的有向图，或者一个简单的图 `A -> B, C -> D`，都不存在这样的根。

***

## 填空题

1. **顺序**
   
    * **解析**: 二分检索（Binary Search）的前提是能够**随机访问**任意位置的元素，特别是中间位置的元素。**顺序存储**结构（如数组）支持 O(1) 复杂度的随机访问，而链式存储访问中间元素需要 O(n) 的时间。
2. **堆排序 (Heap Sort)**
    * **解析**: 这是一个典型的 "Top K" 问题。最优方法是维护一个大小为 5 的**大顶堆**。遍历1000个元素，先用前5个建堆。然后，对于剩下的995个元素，如果当前元素比堆顶元素（5个里面最大的）小，就替换堆顶并调整堆。遍历完后，堆里剩下的就是最小的5个元素。总复杂度为 $O(n \log k)$，其中 n=1000, k=5，效率很高。
3. **13**
   
    * **解析**: 环形队列中元素个数的计算公式为：`(rear - front + capacity) % capacity`。
    * > [!note]
      >
      > 我才知道有公式啊!
    * 代入数值：`(11 - 18 + 20) % 20 = 13 % 20 = 13`。
4. **35, 30**
    * **解析**: 在任意非空二叉树中，设 `n_0`, `n_1`, `n_2` 分别为度为0, 1, 2的节点数，`n` 为总节点数。
    * 性质1: `n_0 = n_2 + 1`
    * 性质2: `n = n_0 + n_1 + n_2`
    * 已知 `n = 101`, `n_0 = 36` (叶子节点)。
    * 由性质1: `n_2 = n_0 - 1 = 36 - 1 = 35`。
    * 由性质2: `101 = 36 + n_1 + 35` => `101 = 71 + n_1` => `n_1 = 30`。
    * 所以，度为2的节点有**35**个，度为1的节点有**30**个。
5. **5**
    * **解析**: 前序序列为 ADC，A 是根节点。剩下的 `DC` 序列可以被划分给左子树和右子树。
        1. 左子树为空，右子树前序为 `DC` (D为根, C为D的左/右孩子，2种)
        2. 左子树前序为 `D`，右子树前序为 `C` (1种)
        3. 左子树前序为 `DC`，右子树为空 (D为根, C为D的左/右孩子，2种)
    * 总共有 `2 + 1 + 2 = 5` 种可能的树型。
6. **ABDGCEF**
    * **解析**:
        1. 后序序列 (GDBEFCA) 的最后一个元素 `A` 是树的根。
        2. 在中序序列 (DGBAECF) 中找到 `A`，`A` 左边 `DGB` 是左子树，右边 `ECF` 是右子树。
        3. 对左子树 `DGB` (中序) 和 `GDB` (后序) 重复此过程，根是 `B`。
        4. 对右子树 `ECF` (中序) 和 `EFC` (后序) 重复此过程，根是 `C`。
        5. 递归构建出整棵树后，进行前序遍历（根->左->右），得到序列 `ABDGCEF`。
7. **8, 40**
    * **解析**: 在从0开始编号的完全二叉树中：
        * 节点 `i` 的父节点编号为 `floor((i - 1) / 2)`。
        * 节点 `i` 的右子女节点编号为 `2 * i + 2`。
    * 编号为18的结点的父结点：`floor((18 - 1) / 2) = floor(8.5) = 8`。
    * 编号为19的结点的右子女结点：`2 * 19 + 2 = 38 + 2 = 40`。
8. **$O(n)$**
    * **解析**: 二路归并排序的每一趟（pass）操作，都是将已排序的子序列两两合并。这个过程需要对 `n` 个元素中的每一个都访问并移动一次，因此每一趟归并的时间复杂度都是线性的，即 $O(n)$。
    
    * > [!note]
      >
      > 分裂是$$O(logn)$$,归并是$$O(n)$$
9. **希尔排序: (46, 80, 60, 38, 40, 70, 56, 22), 归并排序: (70, 46, 56, 38, 80, 40, 60, 22)**
   
    * **解析**:
        * **希尔排序** (降序, 步长4):
            * 原始序列: (46, 70, 56, 38, 40, 80, 60, 22)
            * 分组1 (下标0,4): (46, 40) -> 降序不变
            * 分组2 (下标1,5): (70, 80) -> 降序为 (80, 70)
            * 分组3 (下标2,6): (56, 60) -> 降序为 (60, 56)
            * 分组4 (下标3,7): (38, 22) -> 降序不变
            * 将排序后的元素放回原位，得到第一趟结果: **(46, 80, 60, 38, 40, 70, 56, 22)**。
        * **归并排序** (降序, 第一轮):
            * 将序列两两分组进行排序。
            * (46, 70) -> 降序 (70, 46)
            * (56, 38) -> 降序 (56, 38)
            * (40, 80) -> 降序 (80, 40)
            * (60, 22) -> 降序 (60, 22)
            * 合并后得到第一轮结果: **(70, 46, 56, 38, 80, 40, 60, 22)**。
10. **邻接表**
    * **解析**: 对于稀疏图（边数 |E| 远小于 |V|^2），邻接表的空间复杂度为 O(|V|+|E|)，而邻接矩阵为 O(|V|^2)。因此**邻接表**更节省存储空间。

***

## 简答题

1. **森林周游**
    * **深度优先周游 (Depth-First Traversal)**: 依次对森林中的每棵树进行深度优先（先根）遍历。
        1. 遍历第一棵树 (根A): A -> D -> E -> J -> K -> F
        2. 遍历第二棵树 (根B): B -> G -> L
        3. 遍历第三棵树 (根C): C -> H -> I -> M -> N
        * **序列**: **A, D, E, J, K, F, B, G, L, C, H, I, M, N**
    * **广度优先周游 (Breadth-First Traversal)**: 按层级依次访问森林中所有树的节点。
        1. 第0层: A, B, C
        2. 第1层: D, E, F, G, H, I
        3. 第2层: J, K, L, M, N
        * **序列**: **A, B, C, D, E, F, G, H, I, J, K, L, M, N**
    
    > [!note]
    >
    > 注意这是森林周游

---

2. **哈夫曼树**
    * 给定权值 {4, 8, 6, 9, 18}。
    * **构造过程**:
        1. 初始集合: {(4), (6), (8), (9), (18)}
        2. 合并最小的两个 (4)和(6)，得到新节点(10)。集合: {(8), (9), (10), (18)}
        3. 合并最小的两个 (8)和(9)，得到新节点(17)。集合: {(10), (17), (18)}
        4. 合并最小的两个 (10)和(17)，得到新节点(27)。集合: {(18), (27)}
        5. 合并最后两个 (18)和(27)，得到根节点(45)。
    * **哈夫曼树示意图**:

        ```
              (45)
             /    \
         (18)     (27)
                 /    \
               (10)   (17)
              /  \   /  \
            (4) (6) (8) (9)
        ```

    * **带权外部路径长度 (WPL) 计算**:
        * 方法1：`WPL = Σ(叶子权值 * 深度)`
          `WPL = 18*1 + (4+6+8+9)*3 = 18 + 27*3 = 18 + 81 = 99` (假设根深度为0，18在第1层，4,6,8,9在第3层)。
          `WPL = 18*1 + 4*3 + 6*3 + 8*3 + 9*3 = 18 + 12 + 18 + 24 + 27 = 99`。
        * 方法2：`WPL = 所有非叶子节点的权值之和`
          `WPL = 10 + 17 + 27 + 45 = 99`。
        * **最终 WPL 为 99**。

3. **完全二叉树**

   - 构建小根堆
   - 从最后一个非叶子节点 (索引4，值为20) 开始，依次向前进行“向下调整”。

   * **初始数组**: `[31, 8, 53, 10, 20, 7, 15, 3, 20, 1]`


   * **调整过程简述**:
       1.  **索引 4 (20)**: 与其子节点中更小的 `1` 交换。
           1.  **索引 3 (10)**: 与其子节点中更小的 `3` 交换。
           2.  **索引 2 (53)**: 与其子节点中更小的 `7` 交换。
           3.  **索引 1 (8)**: 与其子节点中更小的 `1` 交换。
           4.  **索引 0 (31)**: 与其子节点中更小的 `1` 交换，交换后 `31` 继续向下与 `3` 交换，再与 `10` 交换。


* **最终小根堆 (数组表示)**: `[1, 3, 7, 10, 8, 53, 15, 31, 20, 20]`

* **图示**:
    ```
            1
          /   \
         3     7
        / \   / \
      10   8 53  15
     / \   /
    31 20 20
    ```

---

- 2) 删除最小元素 

1.  将堆顶 `1` 与最后一个元素 `20` (索引9) 交换。
2.  删除堆末尾的 `1`，堆大小减一。
3.  新的堆顶为 `20`，对其进行“向下调整”。`20` 先与更小的子节点 `3` 交换，交换后 `20` 再与更小的子节点 `8` 交换。

* **最终结果 (数组表示)**: `[3, 8, 7, 10, 20, 53, 15, 31, 20]`

* **图示**:
    ```
            3
          /   \
         8     7
        / \   / \
      10  20 53  15
      / \
    31  20
    ```

---

- 3) 插入元素 

1.  将 `2` 放在堆的末尾。
2.  对 `2` 进行“向上调整”。
    * `2` 比其父节点 `20` (索引4) 小，交换。
    * `2` 比其新的父节点 `8` (索引1) 小，交换。
    * `2` 比其新的父节点 `3` (索引0) 小，交换。

* **最终结果 (数组表示)**: `[2, 3, 7, 10, 8, 53, 15, 31, 20, 20]`

* **图示**:
    
    ```
            2
          /   \
         3     7
        / \   / \
      10   8 53  15
     / \   /
    31 20 20
    ```
---

4. **最小生成树 (Prim算法)**
    * **1) 图 G 的绘制**:
        * 根据邻接矩阵画出包含5个顶点 (V0-V4) 和对应带权边的无向图。
        * (V0,V1,7), (V0,V2,8), (V0,V3,4), (V0,V4,2)
        * (V1,V2,9), (V1,V4,5)
        * (V2,V3,3)

    * **2) Prim 算法求最小生成树 (从V0出发)**:
        1. **起始**: 集合U={V0}。选择与V0相连的最短边 (V0, V4)，权为2。
        2. **第1步**: U={V0, V4}。选择连接U内顶点与U外顶点的最短边 (V0, V3)，权为4。(备选边中有(V4,V1,5), (V0,V3,4)等，4最小)
        3. **第2步**: U={V0, V4, V3}。选择最短边 (V3, V2)，权为3。
        4. **第3步**: U={V0, V4, V3, V2}。选择最短边 (V4, V1)，权为5。
        * 所有顶点均已加入。
        * **最小生成树的边集**: {(V0, V4), (V0, V3), (V3, V2), (V4, V1)}
        * **总权值**: 2 + 4 + 3 + 5 = 14

    * **3) 生成过程图示**:
        * **步骤0**: 只有顶点 V0。
        * **步骤1**: 添加边 (V0, V4)。树: V0-V4。
        * **步骤2**: 添加边 (V0, V3)。树: V4-V0-V3。
        * **步骤3**: 添加边 (V3, V2)。树: V4-V0-V3-V2。
        * **步骤4**: 添加边 (V4, V1)。树: V2-V3-V0-V4-V1。(最终形态)
    
    * > [!note]
        >
        > **Prim 算法的目标:**
        >
        > Prim 算法是一种寻找**连通无向带权图**的**最小生成树 (Minimum Spanning Tree, MST)** 的贪婪算法。最小生成树是包含图中所有顶点，且没有环的，并且其中所有边的权值之和最小的树。
        >
        > **核心思想:**
        >
        > Prim 算法从一个起始顶点开始，逐步构建最小生成树。在每一步中，它选择一条连接已经在生成树中的顶点和不在生成树中的顶点的权值最小的边，并将该顶点添加到树中，从而不断扩大生成树。
        >
        > **工作流程步骤:**
        >
        > 1. **初始化:**
        >    - 选择图中的任意一个顶点 `v0` 作为起始顶点。
        >    - 创建一个集合 `V_MST`，用于存储已经添加到生成树中的顶点。初始时 `V_MST = {v0}`。
        >    - 创建一个集合 `E_MST`，用于存储构成生成树的边。初始时 `E_MST = {}`。
        >    - 创建一个数据结构（通常是**优先队列**），用于存储从 `V_MST` 到达不在 `V_MST` 中的顶点的边。优先队列会根据边的权值进行排序，权值最小的边具有最高的优先级。
        >    - 将与 `v0` 相连的所有边添加到优先队列中。对于每个边 `{v0, v}`，权值为 `w(v0, v)`，将 `(w(v0, v), v0, v)` 添加到优先队列中。
        > 2. **迭代构建:**
        >    - 当优先队列不为空且 `V_MST` 不包含图中的所有顶点时：
        >      - 从优先队列中取出权值最小的边，设这条边为 `(w, u, v)`，其中 `u` 在 `V_MST` 中，`v` 不在 `V_MST` 中。
        >      - 将顶点 `v` 添加到 `V_MST` 中。
        >      - 将边 `{u, v}` 添加到 `E_MST` 中。
        >      - 对于与 `v` 相连的所有边 `{v, x}`：
        >        - 如果 `x` 不在 `V_MST` 中，则将边 `(w(v, x), v, x)` 添加到优先队列中。
        > 3. **终止:**
        >    - 当 `V_MST` 包含图中的所有顶点时，算法终止。
        >    - `E_MST` 中包含了构成最小生成树的所有边。
        >
        > **为什么 Prim 算法是正确的？**
        >
        > - **连通性:** 由于每一步都选择一条连接树中顶点和非树中顶点的边，最终生成的树必然将所有顶点连接起来，因此是连通的。
        > - **无环:** 每次选择的边都是连接一个在树中的顶点和一个不在树中的顶点。这意味着新添加的边不会形成新的环。因此，最终生成的边集 `E_MST` 不包含任何环。
        > - **树的性质:** 对于包含 *n* 个顶点的图，最终生成的边集 `E_MST` 将包含 *n - 1* 条边。因此，它满足树的性质。
        > - **最小权值:** Prim 算法是一种贪婪算法。在每一步中，它都选择当前可用的、权值最小的边。可以证明，这种贪婪选择策略最终得到的是最小生成树。

***

## 算法题

1. **满二叉树前序转后序**
    
    * **思路**: 该函数利用了满二叉树的性质：节点数为 `length` 时，其左右子树的节点数均为 `(length - 1) / 2`。前序是“根-左-右”，后序是“左-右-根”。只需递归地处理左右子树，然后拼接即可。
    * **代码填空**:
    
        ```python
        #返回先根序列 preorder [start:start+length]对应的后根序列
        def pre2post (preorder, start, length):
            if length <= 1: # 基线条件，节点数为0或1
                return preorder[start : start+length] # (1) 返回当前字符或空字符串
            else:
                sub_len = (length - 1) // 2 # (2) 计算子树的长度
                # 递归处理左子树
                left  = pre2post (preorder, start + 1, sub_len) # (3) 左子树从根的下一个位置开始
                # 递归处理右子树
                right = pre2post (preorder, start + 1 + sub_len, sub_len) # (4) 右子树在前序中紧跟左子树
                # 获取根
                root = preorder[start] # (5) 根是当前前序序列的第一个元素
                return left + right + root
        ```
    
    * **各空答案**:
        1. `preorder[start : start+length]` (或 `preorder[start]` 如果 `length==1`)
        2. `(length - 1) // 2`
        3. `start + 1, sub_len`
        4. `start + 1 + sub_len, sub_len`
        5. `preorder[start]`

---

2. **DFS迷宫探索**
    * **思路**: 该程序首先将迷宫地图转换为图的邻接表表示，然后从起点'S'开始，使用深度优先搜索 (DFS) 寻找通向终点'E'的路径。
    * **代码填空**:

        ```python
        # ... (Graph 和 Vertex 类定义) ...
        mazelist = [ ... ]
        
        def mazeGraph (mlist, rows, cols):
            # ...
            if mlist[row][col] == "S":
                vstart = mGraph.getVertex((row, col)) # (1) 获取刚创建的起始节点对象
            # ...
        
        def searchMaze (path, vcurrent): #从vcurrent 节点开始 DFS 搜索迷宫
            vcurrent.setColor('gray')
            path.append(vcurrent.getId())
        
            if vcurrent.getLabel() != "E":
                done = False
                # 遍历所有邻接节点
                for nbr in vcurrent.getConnections(): # (2) 调用方法获取邻居列表
                    if nbr.getColor() == "white":
                        # 递归搜索
                        done = searchMaze(path, nbr) # (3) 传入路径和邻居节点
                        if done:
                            break
                if not done: # 如果从当前节点出发的所有路径都走不通
                    path.pop() # (4) 回溯，将当前节点从路径中移除
            else:
                done = True
            
            return done
        
        # ... (主程序调用)
        ```

    * **各空答案**:
        1. `mGraph.getVertex((row, col))`
        2. `vcurrent.getConnections()`
        3. `path, nbr`
        4. `path.pop()`
