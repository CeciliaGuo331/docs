---
title: 1_OOP
date: 2025-08-14
details: 面向对象编程：封装 继承 多态
---

# 1_OOP

## 封装 (Encapsulation)

### Q1: C++中的“类(class)”是什么？它和C语言的`struct`有什么关系？

**A:**
和 Python 一样，C++ 的 `class` 是一个用来创建对象的“蓝图”。它将\*\*数据（属性）**和**操作数据的函数（行为）\*\*捆绑在一起。

对于有 C 语言背景的你来说，可以这样理解：
C++ 的 `class` 就像一个\*\*“超级 `struct`”\*\*。

在 C 语言中，`struct` 只能捆绑数据：

```c
struct Pet {
    char* name;
    int hunger;
};
// 操作数据的函数是分离的
void feed(struct Pet* p); 
```

在 C++ 中，`class` 将数据和函数一起打包：

```cpp
class Pet {
    // 数据成员 (Member Variables)
    std::string name_; 
    int hunger_;

    // 函数成员 (Member Functions / Methods)
    void feed(); 
};
```

最关键的区别是，C++ 的 `class` 引入了**访问控制**，这就是下一问的核心。

### Q2: 什么是封装？为什么C++这么强调`public`和`private`？

**A:**
**封装 (Encapsulation)** 是面向对象编程的核心思想之一。它的目标是：**隐藏内部复杂的实现细节，只对外暴露一个简单、可控的公共接口。**

这就像一台电视机：

  * **公共接口 (`public`)**: 遥控器上的按钮（电源、音量、换台）。这是设计出来给用户安全使用的。
  * **内部细节 (`private`)**: 电视机内部复杂的电路板、芯片。用户不应该也无法直接触碰它们，否则可能导致电视损坏或行为异常。

在 Python 中，封装主要靠“约定俗成”：在变量名前加下划线 `_` 或 `__` 来“建议”用户不要直接访问。但这只是一种提醒，你仍然可以强制访问。

而在 C++ 中，封装是由**编译器强制执行**的硬性规定：

  * **`public`**: 声明了“公共接口”。类外部的代码**可以**访问。
  * **`private`**: 声明了“内部数据/细节”。类外部的代码**绝对不能**访问，任何尝试都会导致**编译错误**。

这种严格的保护，可以防止对象的状态被意外或恶意地修改（比如把 `hunger_` 设为一个负数），保证了对象的“健康”和行为的可预测性。

`protected` 则是一个专门为继承而生的关键字，我们将在下一章中讨论。

### Q3: 如何定义一个类？`public`和`private`具体怎么写？

**A:**
类的定义通常写在 `.hpp` 或 `.h` 的头文件中。`public` 和 `private` 像是标签，它们下面的所有成员都遵循该标签的访问规则，直到遇到下一个标签或类定义结束。

```cpp
// Pet.hpp
#pragma once
#include <string>

class Pet {
public: // 公共区域：所有“按钮”都放在这里
    // 构造函数：创建对象的“开关”
    Pet(std::string name);

    // 公开的成员函数 (行为)
    void feed();
    void play();
    void printStatus() const; // const 表示这个函数不会修改任何成员变量

private: // 私有区域：所有“内部电路”都放在这里
    // 私有的成员变量 (状态)
    std::string name_;
    int hunger_;
    int happiness_;
    bool isAlive_;

    // 私有的辅助函数，只在内部使用
    void updateState();
}; // 注意：类定义结束时必须有一个分号！
```

> **重要规则**：
>
>   * 用 `class` 关键字定义的类，成员**默认是 `private`**。
>   * 用 `struct` 关键字定义的类，成员**默认是 `public`**。

### Q4: 既然数据是`private`的，那我怎么去读取和修改它呢？

**A:**
通过定义**公共的成员函数**来提供受控的访问。最常见的模式是 **Getter** 和 **Setter**。

  * **Getter**: 一个用于**读取**私有成员值的 `public` 函数。
  * **Setter**: 一个用于**修改**私有成员值的 `public` 函数。

<!-- end list -->

```cpp
// Pet.hpp
class Pet {
public:
    // ...
    // 一个 Getter 函数，用于安全地读取名字
    std::string getName() const;

    // 一个 Setter 函数，用于安全地修改名字
    void setName(std::string newName);

private:
    std::string name_;
    // ...
};
```

```cpp
// Pet.cpp
#include "Pet.hpp"

std::string Pet::getName() const {
    return name_;
}

void Pet::setName(std::string newName) {
    // 在 Setter 中，你可以加入检查逻辑！
    if (!newName.empty()) { // 比如，不允许设置一个空的名字
        name_ = newName;
    }
}
```

这就是封装的威力：你对数据的修改提供了唯一的、可控的渠道，可以在这个渠道里设置“安检”，保证所有修改都是合法的。

### Q5: 对象是如何被创建和初始化的？什么是构造函数？

**A:**
**构造函数 (Constructor)** 是一种特殊的成员函数，在创建类的对象时**自动被调用**。它唯一的职责就是**初始化成员变量**，确保对象一“出生”就处于一个有效的状态。

这与 Python 中的 `__init__(self, ...)` 方法的职责完全相同。

**构造函数的规则：**

1.  函数名与类名**完全相同**。
2.  **没有返回值**，连 `void` 都不写。

**C++ 推荐的写法是使用“成员初始化列表”**：

```cpp
// Pet.cpp

// 构造函数的实现
// : name_(name), hunger_(50), ... 就是成员初始化列表
Pet::Pet(std::string name)
    : name_(name),       // 把参数 name 的值，初始化给成员 name_
      hunger_(50),       // 把 50 初始化给成员 hunger_
      happiness_(50),
      isAlive_(true)
{
    // 函数体可以是空的，因为所有初始化工作都已在上面完成
    std::cout << "宠物 " << name_ << " 诞生了！" << std::endl;
}
```

> **为什么用初始化列表？**
> 这种写法执行的是**初始化 (Initialization)**，比在函数体 `{}` 内部用 `=` 进行**赋值 (Assignment)** 效率更高，并且对于 `const` 或引用类型的成员是**必须**的。

### Q6: 在Python的类方法里，我们总能看到`self`。C++里有类似的东西吗？

**A:**
是的，C++ 中对应的就是 **`this` 指针**。

`this` 是一个隐藏的指针，它指向调用当前成员函数的那个对象实例。在大多数情况下，`this->` 是**隐式**的，可以省略。

```cpp
// 在成员函数中
void Pet::someFunction() {
    hunger_ = 10;       // 实际上是 this->hunger_ = 10;
    printStatus();    // 实际上是 this->printStatus();
}
```

只有在一种情况下**必须**显式使用 `this->`：当函数参数或局部变量与成员变量同名时，用来消除歧义。

```cpp
Pet::Pet(std::string name_) {
    // 必须用 this->name_ 来指明左边的是成员变量
    this->name_ = name_; 
}
```

### Q7: 为什么C++要把一个类分成`.hpp` (头文件) 和 `.cpp` (源文件)？

**A:**
这是 C++ 项目管理的核心，即**声明与实现的分离**。

  * **`.hpp` (头文件)**：存放类的**声明（接口）**。它像一份公开的“API文档”，告诉其他程序员你的类“能做什么”。任何需要使用这个类的文件，都应该 `#include` 这个头文件。
  * **`.cpp` (源文件)**：存放类的**实现（定义）**。它包含了所有成员函数内部的具体逻辑，告诉编译器你的类“如何工作”。

**这样做的好处：**

1.  **清晰**：接口和实现分离，代码结构一目了然。
2.  **高效**：在大型项目中，当你只修改 `.cpp` 文件（实现细节）时，编译器只需要重新编译这一个文件。而如果所有代码都在头文件里，那么每一个包含该头文件的文件都必须重新编译，会浪费大量时间。
3.  **封装**：使用者只能看到 `.hpp` 里的公共接口，看不到 `.cpp` 里的实现细节。

---

## 继承 (Inheritance)

继承是代码复用的基石。它允许我们创建一个通用的“父类”，并让“子类”获取其所有特性，再添加或修改自己的功能，形成一个“家族”体系。

### Q1: C++ 中如何表示“子类是一种父类”的关系？

**A:**
通过**继承 (Inheritance)** 语法。这与 Python 中 `class Child(Parent):` 的概念完全相同。在 C++ 中，我们使用冒号 `:` 来表示。

```cpp
// Pet.hpp (父类/基类)
class Pet {
    // ...
};

// DigitalPet.hpp (子类/派生类)
#include "Pet.hpp" // 子类的头文件必须包含父类的头文件

class DigitalPet : public Pet { // DigitalPet 是一种 Pet
    // ...
};
```

  * `: public Pet` 的意思是“公开地继承 `Pet` 类”。这意味着 `Pet` 的 `public` 成员在 `DigitalPet` 中也是 `public`，`protected` 成员在 `DigitalPet` 中也是 `protected`。这被称为 **"is-a" (是一种)** 关系。

### Q2: 子类如何初始化从父类那里继承来的属性？

**A:**
子类的构造函数**必须**在其**成员初始化列表**中调用父类的构造函数。这与 Python 中在 `__init__`里调用 `super().__init__(...)` 的目的一样，都是为了确保对象的父类部分能被正确地初始化。

```cpp
// 父类 Pet 的构造函数
Pet::Pet(std::string name)
    : name_(name), isAlive_(true) 
{}

// 子类 Cat 的构造函数
Cat::Cat(std::string name, std::string color)
    : Pet(name),      // 1. “承上”：把父类需要的参数 `name` 传递给父类的构造函数
      color_(color)   // 2. “启下”：初始化自己新增的成员 `color_`
{}
```

> **核心规则**：子类不能直接初始化父类的成员，它只能通过调用父类的构造函数来完成这件事。

### Q3: `private` 和 `protected` 在继承中有什么区别？

**A:**
这是 C++ 访问控制的关键。

  * **`private`**: 绝对私有。被声明为 `private` 的成员，**只有本类自己可以访问，子类也无权访问**。
  * **`protected`**: “家庭内部”共享。被声明为 `protected` 的成员，**本类和所有它的子类都可以访问**，但外部（如`main`函数）不能访问。

> **设计原则**：
>
>   * 当你希望某个成员只被本类内部使用，不希望任何子类干涉时，用 `private`。
>   * 当你设计一个父类，并希望子类能够直接使用某些内部数据或辅助函数时，用 `protected`。它就像父类与子孙后代之间的“内部协议”。

### Q4: 继承来的成员，子类可以改变它的访问权限吗？

**A:**
权限可以**维持或放宽**，但**不能收紧**。

  * 子类**不能**把继承来的 `protected` 成员降级为 `private`。
  * 但子类**可以**使用 `using` 声明，将继承来的 `protected` 成员“提升”为 `public`，让其成为自己对外公开接口的一部分。

<!-- end list -->

```cpp
class VeterinaryPet : public Pet {
public:
    // 将父类 Pet 的受保护成员 performHealthCheck 的名字
    // “引入”到当前类的 public 区域
    using Pet::performHealthCheck; 
};
```

### Q5: 父类的所有函数，子类都需要重新声明一遍吗？

**A:**
不，这取决于你的意图：

1.  **直接使用，不改变**：如果父类的函数实现让你完全满意（比如 `Pet::getName()`），你**完全不需要**在子类中做任何事。它会被自动继承。
2.  **提供新版本（重写）**：如果你想让子类对父类的某个**虚函数 (virtual)** 提供自己的特定实现，那么**必须**在子类中重新声明它。这是下一章“多态”的核心。

-----

## 多态 (Polymorphism)

多态是 OOP 最强大的特性。它允许我们通过一个通用的父类接口，来操作不同种类的子类对象，而无需关心它们的具体类型。

### Q1: 什么是虚函数 (Virtual Function)？

**A:**
虚函数是父类提供的一个\*\*“可以被子类重写 (override)”\*\*的函数。它通过 `virtual` 关键字来声明。

你可以把它理解为父类做出的一个承诺：“我的这个函数，欢迎我的子孙后代们根据自己的特点，提供你们自己的版本。”

```cpp
// Pet.hpp
class Pet {
public:
    // 声明一个虚函数
    virtual void speak() const;
};
```

在 C++11 及以后的版本中，子类重写时应使用 `override` 关键字，它能让编译器帮你检查是否真的成功重写了父类的函数，非常安全。

### Q2: 为什么父类的虚函数，在子类中也自动是虚函数？

**A:**
为了**保持多态性在继承链中能够传递下去**。

C++ 的规则是“一次虚，终身虚”。一旦一个函数在基类中被声明为 `virtual`，它在所有派生类中永远都是 `virtual` 的，无论你是否在子类中重复写 `virtual` 关键字。

这保证了多态性不会在继承的中间层“断掉”。一个指向“祖父”类的指针，仍然可以正确调用到“孙子”类中重写的版本。

### Q3: 什么是纯虚函数 (Pure Virtual Function)？它和抽象类有什么关系？

**A:**
纯虚函数是一个在基类中声明，但**没有实现**，并且**强制**所有具体子类必须实现的虚函数。它的语法是在函数声明末尾加上 `= 0`。

```cpp
// Pet.hpp
class Pet {
public:
    // 一个纯虚函数，它没有函数体
    virtual void printStatus() const = 0;
};
```

  * **作用**：它定义了一个**强制性契约**。父类说：“我知道我的所有子类都必须有这个功能，但我自己作为一个抽象概念，无法提供一个有意义的实现。这个任务必须由子类自己完成。”
  * **抽象类**：任何包含至少一个纯虚函数的类，都会自动成为**抽象类 (Abstract Class)**。抽象类**不能被实例化**（即不能创建它的对象），但可以被用作指针或引用，这是多态的基础。

### Q4: 什么是析构函数？为什么父类的析构函数通常要是虚函数？

**A:**

  * **析构函数 (`~ClassName()`)**：是在对象被销毁时自动调用的“清理”函数，主要用于释放资源（如 `new` 出来的内存）。

  * **虚析构函数 (`virtual ~ClassName()`)**：这是 C++ 中最重要的规则之一。

      * **问题**：当你通过一个**父类指针** `delete` 一个**子类对象**时，如果父类的析构函数不是 `virtual` 的，程序将只会调用父类的析构函数，**子类的析构函数永远不会被调用**！这会导致子类申请的所有资源都发生**内存泄漏**。
      * **解决方案**：将父类的析构函数声明为 `virtual`。
        ```cpp
        // Pet.hpp
        class Pet {
        public:
            virtual ~Pet() = default; // 使用 = default 是一种现代C++的简洁写法
        };
        ```
      * 这样，`delete` 时程序会先调用子类的析构函数，然后再自动调用父类的析构函数，保证整个对象被完美地清理干净。

> **黄金法则**：只要一个类可能被用作父类，就应该将其析构函数声明为 `virtual`。

### Q5: 我应该把父类的所有函数都写成虚函数吗？

**A:**
技术上可以，但设计上**不应该**。`virtual` 关键字是一个有意的设计决策，它带有微小的性能和内存开销。

  * **设为 `virtual`**: 当你**期望**子类会为这个行为提供不同实现时（如 `speak`, `printStatus`）。
  * **不设为 `virtual`**: 当这个函数代表了整个家族**固定不变的核心逻辑**时（如 `getName`, `isAlive`）。这样的函数调用更快，也不增加对象大小。